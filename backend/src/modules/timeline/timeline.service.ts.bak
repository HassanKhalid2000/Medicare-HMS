import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../config/prisma.service';
import { TimelineQueryDto } from './dto';

export interface TimelineEvent {
  id: string;
  type: 'appointment' | 'medical_record' | 'diagnosis' | 'prescription' | 'vital_sign' | 'admission' | 'medical_document';
  title: string;
  description: string;
  date: Date;
  status?: string;
  provider?: string;
  category?: string;
  metadata?: any;
}

export interface TimelineResponse {
  events: TimelineEvent[];
  total: number;
  hasMore: boolean;
  summary: {
    totalEvents: number;
    eventTypes: Record<string, number>;
    dateRange: {
      earliest: Date | null;
      latest: Date | null;
    };
  };
}

@Injectable()
export class TimelineService {
  constructor(private prisma: PrismaService) {}

  async getPatientTimeline(
    patientId: string,
    query: TimelineQueryDto = {}
  ): Promise<TimelineResponse> {
    // Verify patient exists
    const patient = await this.prisma.patient.findUnique({
      where: { id: patientId },
      select: { id: true, firstName: true, lastName: true, patientId: true },
    });

    if (!patient) {
      throw new NotFoundException('Patient not found');
    }

    const { startDate, endDate, eventTypes = ['all'], limit = 50, offset = 0 } = query;
    const includeAll = eventTypes.includes('all');

    // Build date filter
    const dateFilter: any = {};
    if (startDate) dateFilter.gte = new Date(startDate);
    if (endDate) dateFilter.lte = new Date(endDate);

    const events: TimelineEvent[] = [];

    // Fetch appointments
    if (includeAll || eventTypes.includes('appointment')) {
      const appointments = await this.prisma.appointment.findMany({
        where: {
          patientId,
          ...(Object.keys(dateFilter).length > 0 && { appointmentDate: dateFilter }),
        },
        include: {
          doctor: {
            select: { name: true, specialization: true },
          },
        },
        orderBy: { appointmentDate: 'desc' },
      });

      events.push(
        ...appointments.map((apt): TimelineEvent => ({
          id: apt.id,
          type: 'appointment',
          title: `Appointment - ${apt.doctor.name}`,
          description: `${apt.doctor.specialization} appointment. Symptoms: ${apt.symptoms || 'General consultation'}`,
          date: apt.appointmentDate,
          status: apt.status,
          provider: apt.doctor.name,
          category: apt.doctor.specialization,
          metadata: {
            duration: apt.duration,
            notes: apt.notes,
            type: apt.type,
          },
        }))
      );
    }

    // Fetch medical records
    if (includeAll || eventTypes.includes('medical_record')) {
      const medicalRecords = await this.prisma.medicalRecord.findMany({
        where: {
          patientId,
          ...(Object.keys(dateFilter).length > 0 && { createdAt: dateFilter }),
        },
        include: {
          doctor: {
            select: { name: true, specialization: true },
          },
        },
        orderBy: { createdAt: 'desc' },
      });

      events.push(
        ...medicalRecords.map((record): TimelineEvent => ({
          id: record.id,
          type: 'medical_record',
          title: `Medical Record - ${record.title}`,
          description: record.chiefComplaint || 'Medical record created',
          date: record.createdAt,
          status: record.status,
          provider: record.doctor.name,
          category: record.recordType,
          metadata: {
            diagnosis: record.diagnosis,
            treatment: record.treatment,
            followUpInstructions: record.followUpInstructions,
          },
        }))
      );
    }

    // Fetch diagnoses
    if (includeAll || eventTypes.includes('diagnosis')) {
      const diagnoses = await this.prisma.diagnosis.findMany({
        where: {
          patientId,
          ...(Object.keys(dateFilter).length > 0 && { diagnosisDate: dateFilter }),
        },
        include: {
          doctor: {
            select: { name: true, specialization: true },
          },
        },
        orderBy: { diagnosisDate: 'desc' },
      });

      events.push(
        ...diagnoses.map((diagnosis): TimelineEvent => ({
          id: diagnosis.id,
          type: 'diagnosis',
          title: `Diagnosis - ${diagnosis.diagnosisName}`,
          description: `${diagnosis.icdCode}: ${diagnosis.description || diagnosis.diagnosisName}`,
          date: diagnosis.diagnosisDate,
          status: diagnosis.status,
          provider: diagnosis.doctor.name,
          category: diagnosis.severity,
          metadata: {
            icdCode: diagnosis.icdCode,
            severity: diagnosis.severity,
            notes: diagnosis.notes,
          },
        }))
      );
    }

    // Fetch prescriptions
    if (includeAll || eventTypes.includes('prescription')) {
      const prescriptions = await this.prisma.prescription.findMany({
        where: {
          patientId,
          ...(Object.keys(dateFilter).length > 0 && { prescribedDate: dateFilter }),
        },
        include: {
          doctor: {
            select: { name: true, specialization: true },
          },
          prescriptionItems: {
            include: {
              medicine: true,
            },
          },
        },
        orderBy: { prescribedDate: 'desc' },
      });

      events.push(
        ...prescriptions.map((prescription): TimelineEvent => ({
          id: prescription.id,
          type: 'prescription',
          title: `Prescription - ${prescription.prescriptionItems.length} medication(s)`,
          description: `Prescribed: ${prescription.prescriptionItems.map(item => item.medicine.name).join(', ')}`,
          date: prescription.prescribedDate,
          status: prescription.status,
          provider: prescription.doctor.name,
          category: 'Medication',
          metadata: {
            medications: prescription.prescriptionItems.map(item => ({
              name: item.medicine.name,
              dosage: item.dosage,
              frequency: item.frequency,
              duration: item.duration,
            })),
            notes: prescription.notes,
          },
        }))
      );
    }

    // Fetch vital signs
    if (includeAll || eventTypes.includes('vital_sign')) {
      const vitalSigns = await this.prisma.vitalSign.findMany({
        where: {
          patientId,
          ...(Object.keys(dateFilter).length > 0 && { measuredAt: dateFilter }),
        },
        orderBy: { measuredAt: 'desc' },
      });

      events.push(
        ...vitalSigns.map((vital): TimelineEvent => ({
          id: vital.id,
          type: 'vital_sign',
          title: `Vital Signs - ${vital.vitalType}`,
          description: `${vital.value} ${vital.unit}${vital.isAbnormal ? ' (Abnormal)' : ''}`,
          date: vital.measuredAt,
          status: vital.isAbnormal ? 'abnormal' : 'normal',
          provider: vital.measuredBy,
          category: vital.vitalType,
          metadata: {
            value: vital.value,
            unit: vital.unit,
            normalRange: vital.normalRange,
            notes: vital.notes,
          },
        }))
      );
    }

    // Fetch admissions
    if (includeAll || eventTypes.includes('admission')) {
      const admissions = await this.prisma.admission.findMany({
        where: {
          patientId,
          ...(Object.keys(dateFilter).length > 0 && { admissionDate: dateFilter }),
        },
        include: {
          doctor: {
            select: { name: true, specialization: true },
          },
        },
        orderBy: { admissionDate: 'desc' },
      });

      events.push(
        ...admissions.map((admission): TimelineEvent => ({
          id: admission.id,
          type: 'admission',
          title: `${admission.status === 'admitted' ? 'Hospital Admission' : 'Admission Discharge'}`,
          description: `${admission.admissionType} - ${admission.reason}`,
          date: admission.status === 'admitted' ? admission.admissionDate : admission.dischargeDate || admission.admissionDate,
          status: admission.status,
          provider: admission.doctor.name,
          category: admission.admissionType,
          metadata: {
            roomNumber: admission.roomNumber,
            ward: admission.ward,
            notes: admission.notes,
            dischargeDate: admission.dischargeDate,
          },
        }))
      );
    }

    // Fetch medical documents
    if (includeAll || eventTypes.includes('medical_document')) {
      const documents = await this.prisma.medicalDocument.findMany({
        where: {
          patientId,
          isActive: true,
          ...(Object.keys(dateFilter).length > 0 && { createdAt: dateFilter }),
        },
        orderBy: { createdAt: 'desc' },
      });

      events.push(
        ...documents.map((document): TimelineEvent => ({
          id: document.id,
          type: 'medical_document',
          title: `Document - ${document.title}`,
          description: document.description || `${document.type.replace('_', ' ')} document uploaded`,
          date: document.createdAt,
          status: 'active',
          provider: document.uploadedBy,
          category: document.type,
          metadata: {
            fileName: document.fileName,
            fileSize: document.fileSize,
            mimeType: document.mimeType,
          },
        }))
      );
    }

    // Sort all events by date (newest first)
    events.sort((a, b) => b.date.getTime() - a.date.getTime());

    // Pagination
    const total = events.length;
    const paginatedEvents = events.slice(offset, offset + limit);
    const hasMore = offset + limit < total;

    // Calculate summary
    const eventTypeCounts = events.reduce((acc, event) => {
      acc[event.type] = (acc[event.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const dates = events.map(e => e.date);
    const earliest = dates.length > 0 ? new Date(Math.min(...dates.map(d => d.getTime()))) : null;
    const latest = dates.length > 0 ? new Date(Math.max(...dates.map(d => d.getTime()))) : null;

    return {
      events: paginatedEvents,
      total,
      hasMore,
      summary: {
        totalEvents: total,
        eventTypes: eventTypeCounts,
        dateRange: {
          earliest,
          latest,
        },
      },
    };
  }

  async getTimelineSummary(patientId: string): Promise<{
    recentActivity: TimelineEvent[];
    upcomingEvents: TimelineEvent[];
    criticalAlerts: TimelineEvent[];
  }> {
    // Verify patient exists
    const patient = await this.prisma.patient.findUnique({
      where: { id: patientId },
    });

    if (!patient) {
      throw new NotFoundException('Patient not found');
    }

    const now = new Date();
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

    // Get recent activity (last 7 days)
    const recentTimeline = await this.getPatientTimeline(patientId, {
      startDate: sevenDaysAgo.toISOString(),
      endDate: now.toISOString(),
      limit: 10,
    });

    // Get upcoming appointments
    const upcomingAppointments = await this.prisma.appointment.findMany({
      where: {
        patientId,
        appointmentDate: {
          gte: now,
          lte: thirtyDaysFromNow,
        },
        status: 'scheduled',
      },
      include: {
        doctor: {
          select: { name: true, specialization: true },
        },
      },
      orderBy: { appointmentDate: 'asc' },
      take: 5,
    });

    const upcomingEvents: TimelineEvent[] = upcomingAppointments.map((apt): TimelineEvent => ({
      id: apt.id,
      type: 'appointment',
      title: `Upcoming - ${apt.doctor.name}`,
      description: `${apt.doctor.specialization} appointment`,
      date: apt.appointmentDate,
      status: apt.status,
      provider: apt.doctor.name,
      category: apt.doctor.specialization,
    }));

    // Get critical alerts (abnormal vital signs, critical diagnoses)
    const criticalVitals = await this.prisma.vitalSign.findMany({
      where: {
        patientId,
        isAbnormal: true,
        measuredAt: {
          gte: sevenDaysAgo,
        },
      },
      orderBy: { measuredAt: 'desc' },
      take: 5,
    });

    const criticalAlerts: TimelineEvent[] = criticalVitals.map((vital): TimelineEvent => ({
      id: vital.id,
      type: 'vital_sign',
      title: `⚠️ Abnormal ${vital.type}`,
      description: `${vital.value} ${vital.unit} - Outside normal range`,
      date: vital.measuredAt,
      status: 'critical',
      provider: vital.measuredBy,
      category: 'Alert',
    }));

    return {
      recentActivity: recentTimeline.events,
      upcomingEvents,
      criticalAlerts,
    };
  }
}